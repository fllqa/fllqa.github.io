<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fanlili&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-02-20T07:35:08.016Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fanlili</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>thread</title>
    <link href="http://yoursite.com/2017/02/20/thread/"/>
    <id>http://yoursite.com/2017/02/20/thread/</id>
    <published>2017-02-20T07:35:07.000Z</published>
    <updated>2017-02-20T07:35:08.016Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>exception</title>
    <link href="http://yoursite.com/2017/02/20/exception/"/>
    <id>http://yoursite.com/2017/02/20/exception/</id>
    <published>2017-02-20T07:34:43.000Z</published>
    <updated>2017-02-20T07:34:43.383Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>refelection</title>
    <link href="http://yoursite.com/2017/02/20/refelection/"/>
    <id>http://yoursite.com/2017/02/20/refelection/</id>
    <published>2017-02-20T07:27:35.000Z</published>
    <updated>2017-02-20T07:27:35.056Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>variable</title>
    <link href="http://yoursite.com/2017/02/19/variable/"/>
    <id>http://yoursite.com/2017/02/19/variable/</id>
    <published>2017-02-19T12:46:32.000Z</published>
    <updated>2017-02-23T03:03:23.795Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中的成员变量、局部变量、静态变量、类变量、非静态变量、实例变量。<br>在Java中变量大致上可以分为成员变量与局部变量两大类。</p>
<p>###成员变量</p>
<ol>
<li>在类里面定义的变量称为成员变量。</li>
<li>如果前面有static修饰，则该成员变量为静态变量或者类变量。</li>
<li>如果前面无static修饰，则该成员变量为非静态变量或实例变量。<br>####静态变量</li>
<li>变量属于类本身</li>
<li>类变量不依赖类的实例，类变量只在初始化时候在栈内存中被分配一次空间，无论类的实例被创建几次，都不再为类变量分配空间</li>
<li>通过类的任意一个实例来访问类变量，底层都将将其转为通过类本身来访问类变量，它们的效果是一样的</li>
<li>一旦类变量的值被改变，通过类或类的任意一个实例来访问类变量，得到的都将是被改变后的值</li>
<li>将在类的初始化之前初始化<br>####实例变量</li>
<li>变量属于类的实例对象</li>
<li>随着类的实例被创建而分配内存空间<br>###局部变量<br>形参、方法内定义的变量、代码块中定义的变量。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中的成员变量、局部变量、静态变量、类变量、非静态变量、实例变量。&lt;br&gt;在Java中变量大致上可以分为成员变量与局部变量两大类。&lt;/p&gt;
&lt;p&gt;###成员变量&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在类里面定义的变量称为成员变量。&lt;/li&gt;
&lt;li&gt;如果前面有static修饰
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>extends</title>
    <link href="http://yoursite.com/2017/02/19/extends/"/>
    <id>http://yoursite.com/2017/02/19/extends/</id>
    <published>2017-02-19T11:40:58.000Z</published>
    <updated>2017-02-23T03:04:10.616Z</updated>
    
    <content type="html"><![CDATA[<p>这次主要分析一下类的关键字</p>
<p>##extends<br>extends表示的是继承，孩子类继承父类，子类继承超类，继承是一种is-a的关系。</p>
<p>###示例<br>    public class Manager extends Employee()<br>    {<br>    }</p>
<p>###子类可以重写父类的方法（覆盖）<br>这里需要注意，如果子类中重写的这个方法也要用到父类中同名的方法，可以用到super.getSalary()</p>
<p>###多态<br>一个对象变量可以指示多种实际类型的现象为多态。</p>
<p>##final<br>不允许扩展的类称为final类，即final类不能定义子类。同样子类不能覆盖的方法叫做final方法</p>
<p>###final类</p>
<p>####示例<br>    public final class Manager extends Employee()<br>    {<br>    }</p>
<p>###final方法</p>
<p>####示例<br>    public class test<br>    {<br>        public final String getName()<br>        {<br>        }<br>    }</p>
<p>###final变量（实例变量，静态变量，常量）</p>
<p>####示例<br>    public class finalTest<br>    {<br>        private final String S = “final实例变量S”;<br>        private final int A = 100;<br>        public final int B = 90; </p>
<pre><code>    public static final int C = 80; //同static一起定义常量
    private static final int D = 70; 

    public final int E; //final空白,必须在初始化对象的时候赋初值 

    public finalTest(int x) 
    { 
        E = x; 
    } 

    /** 
     * @param args 
     */ 
    public static void main(String[] args)
    { 
        finalTest t = new finalTest(2); 
        //t.A=101;    //出错,final变量的值一旦给定就无法改变 
        //t.B=91; //出错,final变量的值一旦给定就无法改变 
        //t.C=81; //出错,final变量的值一旦给定就无法改变 
        //t.D=71; //出错,final变量的值一旦给定就无法改变 

        System.out.println(t.A); 
        System.out.println(t.B); 
        System.out.println(t.C); //不推荐用对象方式访问静态字段 
        System.out.println(t.D); //不推荐用对象方式访问静态字段 
        System.out.println(finalTest.C); 
        System.out.println(finalTest.D); 
        //System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. 
        System.out.println(t.E); 

        finalTest t1 = new finalTest(3); 
        System.out.println(t1.E); //final空白变量E依据对象的不同而不同 
    } 
}
</code></pre><p>##abstract抽象类<br>包含一个或多个抽象方法的类必须被声明为抽象的。在子类中都有必要的操作要进行，但是在超类中却没有什么相关操作需要进行的方法为抽象方法,具体的实现在子类。</p>
<p>###示例<br>    public abstract class Person<br>    {<br>        private String name;<br>        public Person(String name)<br>        {<br>            this.name=name;<br>        }<br>        public abstract String getDescription();<br>    }</p>
<p>###一些注意的地方</p>
<ol>
<li>abstract不能被实例化，即不能创建这个类的对象，但是可以创建一个具体子类的对象。只能引用非抽象子类的对象。</li>
<li>扩展抽象类有两种方法：抽象类中定义部分或者不定义抽象类方法，子类也为abstract类。</li>
<li>抽象类中定义全部抽象方法，子类不是abstract类。</li>
<li>abstract 关键字不能应用于 static、private 或 final 方法，因为这些方法不能被重写，因此，不能在子类中实现。</li>
<li>final 类的方法都不能是 abstract，因为 final 类不能有子类。<br>##java中的访问权限</li>
<li>private只有本类可见</li>
<li>Protected本包与所有子类可见</li>
<li>public所有类都可以看到</li>
<li>没有修饰符，只对本包可见。default,不能声明变量。<br><img src="/images/Java访问权限.jpg" alt="img"></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次主要分析一下类的关键字&lt;/p&gt;
&lt;p&gt;##extends&lt;br&gt;extends表示的是继承，孩子类继承父类，子类继承超类，继承是一种is-a的关系。&lt;/p&gt;
&lt;p&gt;###示例&lt;br&gt;    public class Manager extends Employee()&lt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="http://yoursite.com/2017/02/18/Collection/"/>
    <id>http://yoursite.com/2017/02/18/Collection/</id>
    <published>2017-02-18T10:38:23.000Z</published>
    <updated>2017-02-23T03:03:50.612Z</updated>
    
    <content type="html"><![CDATA[<p>Java集合框架为不同类型的集合定义了大量的接口，这里主要讲解Collection接口，Map接口，Iterator接口。</p>
<p>##Collection接口</p>
<p>###Collection集合体系继承树<br> <img src="/images/Collection集合体系继承树.jpg" alt="img"></p>
<p>###Collection接口定义的常用方法</p>
<ol>
<li>Set中的数据对象没有顺序且不可以重复。</li>
<li><p>List中的数据对象有顺序且可以重复。</p>
<pre><code>public class CollectioDemo 
{
    public static void main(String[] args)
    {
        Collection li=new ArrayList();
        System.out.println(li);//tostring()方法
        li.add(&quot;fanlili&quot;);
        li.add(&quot;徐ss&quot;);
        System.out.println(li);
        Collection li2=new ArrayList();//将一个集合加入到另一个集合中
        li2.add(&quot;kek&quot;);
        li2.add(&quot;mm&quot;);
        li2.addAll(li);
        System.out.println(li2);
        Collection li3=new ArrayList();//对数字的添加直接做了装箱，其实就是Integer
        li3.add(1);
        li3.add(3);
        li3.add(&quot;既有数值又有字符串&quot;);//一般存储同一类型的数据
        System.out.println(li3);
        System.out.println(&quot;-----------------------删除&quot;);
        /*li2.clear();
        System.out.println(li2);*/

        /*li3.remove(1);
        System.out.println(li3);/*?????li2为什么结果不同？？？*/

        /*li2.removeAll(li);
        System.out.println(li2);*/
        System.out.println(&quot;-----------------------是否包含&quot;);
        boolean isexist=li.contains(&quot;fanlili&quot;);
        System.out.println(isexist);

        boolean isexist2=li2.containsAll(li);
        System.out.println(isexist2);

        boolean isempty=li2.isEmpty();
        System.out.println(isempty);

        Object[] obarray=li2.toArray();//较为重要的将集合转换为数组
        for(int i=0;i&lt;obarray.length;i++)
        {
            System.out.println(obarray[i]);
        }
    }
}
</code></pre></li>
</ol>
<p>运行结果：</p>
<pre><code>[]
[fanlili, 徐ss]
[kek, mm, fanlili, 徐ss]
[1, 3, 既有数值又有字符串]
-----------------------删除
-----------------------是否包含
true
true
false
kek
mm
fanlili
徐ss
</code></pre><p>####List</p>
<p>#####ArrrayList常用方法（也有collection的那些方法）<br>    public class ListDemo<br>    {<br>        public static void main(String[] args)<br>        {<br>            List list=new ArrayList();<br>            list.add(“fanlili”);<br>            list.add(“ggg”);<br>            list.add(1, “xumeng”);//在哪个后面插<br>            list.add(“fanliliwww”);<br>            System.out.println(list);<br>            Object ob=list.get(2);//根据索引获取元素<br>            System.out.println(ob);<br>            int num=list.size(); //获取list的元素个数<br>            System.out.println(num);<br>            ListIterator iter=list.listIterator();//ListIterator功能更加强大<br>            while(iter.hasNext())<br>            {<br>                Object obj=iter.next();<br>                System.out.println(obj);<br>            }<br>            System.out.println(“—————————————-“);<br>            String str= (String)iter.previous();//实现从后向前遍历<br>            System.out.println(str);<br>            int pindex=iter.previousIndex();//previousIndex来指示下一个previous()要读取的元素位置<br>            System.out.println(pindex);<br>        }<br>    }</p>
<p>运行结果如下：</p>
<pre><code>[fanlili, xumeng, ggg, fanliliwww]
ggg
4
fanlili
xumeng
ggg
fanliliwww
----------------------------------------
fanliliwww
2
</code></pre><p>#####vector常用方法（也有collection的那些方法）<br>    public class VectorDemo<br>    {<br>        public static void main(String[] args)<br>        {<br>            Vector al=new Vector();//构造一个空向量<br>            al.addElement(1);<br>            System.out.println(al);<br>            al.addElement(new student(“徐ww”,30));<br>            al.addElement(new student(“樊dd”,88));<br>            al.addElement(new student(“文ww”,30));<br>            System.out.println(al);<br>            student stu=(student) al.elementAt(1);<br>            System.out.println(stu);<br>        }<br>    }</p>
<p>运行结果：</p>
<pre><code>[1]
[1, student [name=徐ww, age=30], student [name=樊dd, age=88], student [name=文dd, age=30]]
student [name=徐ww, age=30]
</code></pre><p>#####LinkedList常用方法</p>
<pre><code>    boolean    add(E e) 
              将指定元素添加到此列表的结尾。
     void    add(int index, E element) 
              在此列表中指定的位置插入指定的元素。
     boolean    addAll(Collection&lt;? extends E&gt; c) 
              添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。
     boolean    addAll(int index, Collection&lt;? extends E&gt; c) 
              将指定 collection 中的所有元素从指定位置开始插入此列表。
     void    addFirst(E e) 
              将指定元素插入此列表的开头。
     void    addLast(E e) 
              将指定元素添加到此列表的结尾。
     void    clear() 
              从此列表中移除所有元素。
     Object
    clone() 
              返回此 LinkedList 的浅表副本。
     boolean    contains(Object o) 
              如果此列表包含指定元素，则返回 true。
     Iterator&lt;E&gt;
    descendingIterator() 
              返回以逆向顺序在此双端队列的元素上进行迭代的迭代器。
     E
    element() 
              获取但不移除此列表的头（第一个元素）。
     E
    get(int index) 
              返回此列表中指定位置处的元素。
     E
    getFirst() 
              返回此列表的第一个元素。
     E
    getLast() 
              返回此列表的最后一个元素。
     int    indexOf(Object o) 
              返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。
     int    lastIndexOf(Object o) 
              返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。
     ListIterator&lt;E&gt;
    listIterator(int index) 
              返回此列表中的元素的列表迭代器（按适当顺序），从列表中指定位置开始。
     boolean    offer(E e) 
              将指定元素添加到此列表的末尾（最后一个元素）。
     boolean    offerFirst(E e) 
              在此列表的开头插入指定的元素。
     boolean    offerLast(E e) 
              在此列表末尾插入指定的元素。
     E
    peek() 
              获取但不移除此列表的头（第一个元素）。
     E
    peekFirst() 
              获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。
     E
    peekLast() 
              获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。
     E
    poll() 
              获取并移除此列表的头（第一个元素）
     E
    pollFirst() 
              获取并移除此列表的第一个元素；如果此列表为空，则返回 null。
     E
    pollLast() 
              获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。
     E
    pop() 
              从此列表所表示的堆栈处弹出一个元素。
     void    push(E e) 
              将元素推入此列表所表示的堆栈。
     E
    remove() 
              获取并移除此列表的头（第一个元素）。
     E
    remove(int index) 
              移除此列表中指定位置处的元素。
     boolean    remove(Object o) 
              从此列表中移除首次出现的指定元素（如果存在）。
     E
    removeFirst() 
              移除并返回此列表的第一个元素。
     boolean    removeFirstOccurrence(Object o) 
              从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。
     E
    removeLast() 
              移除并返回此列表的最后一个元素。
     boolean    removeLastOccurrence(Object o) 
              从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。
     E
    set(int index, E element) 
              将此列表中指定位置的元素替换为指定的元素。
     int    size() 
              返回此列表的元素数。
     Object[]
    toArray() 
              返回以适当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组。
    &lt;T&gt; T[]
        toArray(T[] a) 
              返回以适当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组；返回数组的运行时类型为指定数组的类型。
public class LinkedListDemo 
{
    public static void main(String[] args) 
    {
        stack();
    }
    public static void stack()
    {
        LinkedList al=new LinkedList();
        al.push(new student(&quot;徐ww&quot;,30));
        al.push(new student(&quot;樊dd&quot;,88));
        al.push(new student(&quot;文dd&quot;,30));
        student stu=(student) al.pop();
        System.out.println(&quot;------------------------&quot;);
        Iterator iter=al.iterator();
        while(iter.hasNext())
        {
            //获得集合中的一个元素
            Object obj=iter.next();
            System.out.println(obj);
        }
    }
}
</code></pre><p>运行结果：</p>
<pre><code>------------------------
student [name=樊dd, age=88]
student [name=徐ww, age=30]
</code></pre><p> *push元素推入此列表所表示的堆栈，add是将指定元素添加到此列表的结尾。</p>
<p>#####三者的区别：</p>
<ol>
<li>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</li>
<li>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</li>
<li><p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。<br>####插入一个泛型示例<br>*为了创建容器类，有了泛型，用&lt;&gt;括起来，在编译期，是无法知道K和V具体是什么类型，只有在运行时才会真正根据类型来构造和分配内存。</p>
</li>
<li><p>泛型接口</p>
<pre><code>public interface Generator&lt;T&gt;
public class FruitGenerator implements Generator&lt;String&gt;
FruitGenerator generator = new FruitGenerator();
</code></pre></li>
<li><p>泛型类 </p>
<pre><code>public class Test&lt;T&gt;{}
Test&lt;Object&gt; t = new Test&lt;Object&gt;();
</code></pre></li>
<li><p>泛型方法</p>
<pre><code>public static &lt;T&gt; void out(T t) 
{
   System.out.println(t);
}
</code></pre></li>
<li><p>结合集合的示例</p>
<pre><code>public interface BaseDao&lt;T&gt; 
{
    public void save(T t);
    public T getT(Integer i);
    public List&lt;T&gt;     listT();
}

public class StudentImplDemo implements BaseDao&lt;student&gt; 
{
    List&lt;student&gt; sList=new ArrayList&lt;student&gt;();

    @Override
    public void save(student t) 
    {

        sList.add(t);
    }

    @Override
    public student getT(Integer i) 
    {
        sList.get(i);
        return null;
    }

    @Override
    public List&lt;student&gt; listT() 
    {

        return sList;
    }

}

public class studentTest 
{
    private static BaseDao&lt;student&gt; basedao=new StudentImplDemo();

    public static void main(String[] args) 
    {
        student s=new student(&quot;xumeng&quot; ,88);
        student s1=new student(&quot;xumengf&quot; ,80);
        basedao.save(s);
        basedao.save(s1);
        List&lt;student&gt; slist=basedao.listT();
        System.out.println(slist);

    }
}   
</code></pre></li>
</ol>
<p>####Set</p>
<p>#####</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java集合框架为不同类型的集合定义了大量的接口，这里主要讲解Collection接口，Map接口，Iterator接口。&lt;/p&gt;
&lt;p&gt;##Collection接口&lt;/p&gt;
&lt;p&gt;###Collection集合体系继承树&lt;br&gt; &lt;img src=&quot;/images/Col
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MavenStudy</title>
    <link href="http://yoursite.com/2017/01/30/MavenStudy/"/>
    <id>http://yoursite.com/2017/01/30/MavenStudy/</id>
    <published>2017-01-30T08:33:14.000Z</published>
    <updated>2017-02-05T15:14:17.091Z</updated>
    
    <content type="html"><![CDATA[<p>Maven是用来干什么的<br>管理项目的工具<br>下载<br>我的jdk是1.8<br>下载版本为3.3.9<br>配置环境变量<br>配置 maven 环境变量(系统变量)：MAVEN_HOME F:\maven\apache-maven-3.3.9<br>在path中添加：;%MAVEN_HOME%\bin<br>maven 版的helloworld<br>maven 要用到本地仓库，没有会去联网下载</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Maven是用来干什么的&lt;br&gt;管理项目的工具&lt;br&gt;下载&lt;br&gt;我的jdk是1.8&lt;br&gt;下载版本为3.3.9&lt;br&gt;配置环境变量&lt;br&gt;配置 maven 环境变量(系统变量)：MAVEN_HOME F:\maven\apache-maven-3.3.9&lt;br&gt;在path
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>你好</title>
    <link href="http://yoursite.com/2017/01/29/tet/"/>
    <id>http://yoursite.com/2017/01/29/tet/</id>
    <published>2017-01-29T04:04:28.000Z</published>
    <updated>2017-01-29T04:08:28.790Z</updated>
    
    <content type="html"><![CDATA[<p>首先需要明白在这里怎么发表博客怎么来玩<br>我觉得我们都要这样爱初二呼和扩说扩军多活菌多菌或扩多索扩所扩军多敷或多敷或获付俊福军副扩<br><a id="more"></a><br>    <img src="/images/fll.jpg" alt="img"><br>    <img src="http://ok9uy2u37.bkt.clouddn.com/fll.jpg" alt="img"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先需要明白在这里怎么发表博客怎么来玩&lt;br&gt;我觉得我们都要这样爱初二呼和扩说扩军多活菌多菌或扩多索扩所扩军多敷或多敷或获付俊福军副扩&lt;br&gt;
    
    </summary>
    
      <category term="测试" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="练习" scheme="http://yoursite.com/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2017/01/29/test/"/>
    <id>http://yoursite.com/2017/01/29/test/</id>
    <published>2017-01-28T16:08:17.000Z</published>
    <updated>2017-01-29T06:58:14.098Z</updated>
    
    <content type="html"><![CDATA[<p>hwhwhwhwhwhwhwhwwhwhhwhwhwhwhwwwwwwwww是护手霜上海市<br><a id="more"></a><br>jdjdjdjdj是护手霜上海市shh</p>
<div id="jj" class="post-more-link"><br>  <a href="#" class="btn">MyButton</a><br></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hwhwhwhwhwhwhwhwwhwhhwhwhwhwhwwwwwwwww是护手霜上海市&lt;br&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/01/25/hello-world/"/>
    <id>http://yoursite.com/2017/01/25/hello-world/</id>
    <published>2017-01-24T16:48:04.881Z</published>
    <updated>2017-01-28T10:38:34.115Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
