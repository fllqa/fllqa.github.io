<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Abstract]]></title>
      <url>%2F2017%2F03%2F20%2FAbstract%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis]]></title>
      <url>%2F2017%2F03%2F18%2Fredis%2F</url>
      <content type="text"><![CDATA[定义REmote DIctionary Server，是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器。 与Memcached相比的优点 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。支持很多较为复杂的数据类型。 Redis支持数据的备份。能干嘛 内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务。 取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面。 模拟类似于HttpSession这种需要设定过期时间的功能。 发布、订阅消息系统。# 单进程模型来处理客户端的请求。对读写等事件的响应是通过对epoll函数的包装来做到的。 默认16个数据库，类似数组下表从零开始，初始默认使用零号库。 Select命令切换数据库 select 2 Redis索引都是从零开始 Dbsize查看当前数据库的key的数量 tab可以补全。 Flushdb：清空当前库。 Flushall；通杀全部库。5大数据类型String（字符串） string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。 是二进制安全的。即redis的string可以包含任何数据。 string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512MHash（哈希） 是一个键值对集合。 是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的Map（散列表，要无都无，无序，不能重复）List（列表）列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。它的底层实际是个链表（LinkedList要有都有，有序，可以重复）Set（集合）Redis的Set是string类型的无序集合。它是通过HashTable实现实现的。（Java中HashTable,HashMash底层一样都是Hashmap）zset(sorted set：有序集合)Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。数据类型keys *判断某个key是否存在 exists key1当前库就没有了，被移除了，移到另一个库中 move k2 2为给定的key设置过期时间 expire k2 10查看你的key是什么类型 type k3查看还有多少秒过期，-1表示永不过期，-2表示已过期（过期已经死，被移除） ttl key1appendstrlen]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux常用命令]]></title>
      <url>%2F2017%2F03%2F18%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[cp 拷贝文件file1并更名为file2 cp file1 file2 拷贝kerry目录下文件到tmp目录下 cp /home/kerry/* /tmp 将目录下的所有目录包括子目录陆续复制到另外一个目录 cp -r /home/tomcat/ /tmp/bak cp redis.conf /myredismv将file_1.txt移动到/home/pungki/office这里（原来的txt将没有）mv file_1.txt /home/pungki/office tar -zxvf redis-3.0.4.tar.gz ls -l gcc -vmake/usr 相当于program filescd /usr/local/bin默认的安装路径mkdir /myredis 新建一个文件夹ls -l /myredisvim redis.conf查看有没有启动redis服务， ps -ef|grep redis启动 redis-server /myredis/redis.confredis-cli -p 6379set k1 helloget k1shutdownredis-benchmark(整redis)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nosqlStudy]]></title>
      <url>%2F2017%2F03%2F18%2FnosqlStudy%2F</url>
      <content type="text"><![CDATA[这次简单的总结了一下自己对NoSql的理解。 简介传统的是关系型数据库RDMBS（Relational Database Management System）,NoSQL(Not Only SQL)用于超大规模数据的存储。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 遵循的规则对比关系型数据库遵循ACID原则 A原子性原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。 C一致性一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。 I独立性所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的 D原子性持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失 Nosql数据库遵循CAPBaseBASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。 基本可用（Basically Available） 软状态（Soft state） 最终一致（Eventually consistent）它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。 一些需要注意的 CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。 根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类： CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。 CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。 AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。 为什么要使用NosqlNoSQL数据模型简介BasonBSON（）是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象。 聚合模型key-ValueBason列族图形 Nosql数据库的4大分类KV键值文档型数据库列存储数据库图关系数据库三大基石CAPBase最终一致性1分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作。 2集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[thread2]]></title>
      <url>%2F2017%2F03%2F17%2Fthread2%2F</url>
      <content type="text"><![CDATA[在同步中休眠的时候锁会不会被释放。（在第一个线程休眠的时候，第二个线程可以进入么）答案是不可以的。线程的休眠是很必要的，为了减少服务器的压力，需要休眠。 线程间的通信生产者消费者wait 与notify是成对出现的，并且都在synchronized之中，生产者与消费者的实现一定在while（true)中。 线程之间的优先级问题 线程的优先级是为了在多线程环境中便于系统对线程的调度，优先级高的线程将优先执行。 一个线程的优先级设置遵从以下原则： 线程创建时，子继承父的优先级。 线程创建后，可通过调用setPriority()方法改变优先级。 线程的优先级是1-10之间的正整数。 1- MIN_PRIORITY 10-MAX_PRIORITY 5-NORM_PRIORITY 如果什么都没有设置，默认值是5。 但是不能依靠线程的优先级来决定线程的执行顺序。只能是值越大占有资源多些。 join等待该线程终止，就是在一个线程start()之后，join会抢先拿到CPU执行线程，其他的线程都要等这个线程终止了才可以继续抢占CPU。暂停当前正在执行的线程对象，并执行其他线程。 yieldyield 回到就绪状态，让出CPU。 守护线程setDaemon 将该线程标记为守护线程或用户线程会随着主线程的结束而结束。 死锁]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JunitTest]]></title>
      <url>%2F2017%2F03%2F16%2FJunitTest%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[log4j]]></title>
      <url>%2F2017%2F03%2F16%2Flog4j%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据库存储引擎]]></title>
      <url>%2F2017%2F03%2F15%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL常用语句]]></title>
      <url>%2F2017%2F03%2F15%2FSQL%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%2F</url>
      <content type="text"><![CDATA[(constraints distinct)cd c:\Program Files\MySQL\MySQL Server 5.7\binmysql -uroot -pshow databasesuse taotaocreate database test1desc taotaocreate table emp(ename varchar(10),hiredate date,sal decimal(10,2), deptno int(2));insert into emp(ename,hiredate,sal,deptno) values(‘tom’,’2003-11-10’,’3000’,2);insert into emp values(‘Lisa’,’2003-11-10’,’3000’,2);valuse的顺序与后面字段的排列顺序一致。insert into emp values(‘Lisa’,’2003-11-10’,’3000’,3),(‘Lishi’,’2003-11-10’,’3000’,4);可以一次性插入多条数据。update emp set sal=4000 where ename=’lisa’;多表更新update emp a,dept b set a.sal=a.sal*b.deptno,b.deptname=a.ename where a.deptno=b.deptno;alter table dept change deptame deptname varchar(10);更改字段名delete from emp where ename=’Lisi’; select * from emp;select distinct deptno from emp;(只显示不重复的deptno，只有deptno这一列）。 表类型的选择（就是存储引擎的选择）show variables like ‘table_type’;（不能用无效果）show variables like ‘have%’;查询当前数据库支持的存储引擎。create table test2(name char(10))engine=myisam;（必须有一列才可以）show create table test2 \G(看搜索引擎 不要分号）show tablesinsert into test2 values(‘abcde’),(‘abcde ‘),(‘ abcde’),(‘ abcde ‘);select name,length(name) from test2; 测试一下InnoDB的自增长create table autoincre_demo(i smallint not null auto_increment,name varchar(10),primary key(i))engine=innodb;insert into autoincre_demo values(1,’1’),(2,’2’),(3,’3’),(null,’4’);select LAST_INSERT_ID();一次性插入多条则返回的是第一个。只有InnoDB支持外键，要求父表必须有对应的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zhizhen]]></title>
      <url>%2F2017%2F03%2F15%2Fzhizhen%2F</url>
      <content type="text"><![CDATA[一维数组定义类型标识符 数组名[常量表达式];常量表达式可以包括常量、常变量和符号常量，但不能包含变量。 初始化 在定义数组时分别对数组元素赋予初值 1int a[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;; 在对全部数组元素赋初值时，可以不指定数组长度。 二维数组定义 类型标识符 数组名[常量表达式][常量表达式];我们可以把二维数组看作是一种特殊的一维数组：它的元素又是一个一维数组。例如，可以把a看作是一个一维数组，它有3个元素：a[0]，a[1]，a[2]，每个元素又是一个包含4个元素的一维数组。 初始化 分行给二维数组赋初值。 可以将所有数据写在一个花括号内，按数组排列的顺序对各元素赋初值 1int a[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125; 如果对全部元素都赋初值（即提供全部初始数据），则定义数组时对第一维的长度可以不指定，但第二维的长度不能省。 关于*的一些操作####一维数组 int a[5]={1,3,5,7,9}; cout&lt;&lt;”a: “&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;”a+1 :”&lt;&lt;a+1&lt;&lt;endl; cout&lt;&lt;”a: “&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;”a+1 :”&lt;&lt;a+1&lt;&lt;endl; cout&lt;&lt;”a[0]: “&lt;&lt;a[0]&lt;&lt;endl; cout&lt;&lt;”a[1]: “&lt;&lt;a[1]&lt;&lt;endl; cout&lt;&lt;”a[0]+1: “&lt;&lt;a[0]+1&lt;&lt;endl; cout&lt;&lt;”——————————————————————“&lt;&lt;endl; cout&lt;&lt;”(a+1) :”&lt;&lt;(a+1)&lt;&lt;endl; cout&lt;&lt;”——————————————————————“&lt;&lt;endl; 运行结果 二维数组 int main(int argc, char* argv[]) { int a[][5]={{1,3,5,7,9},{11,13,15,17,19},{21,23,25,27,29}}; cout&lt;&lt;&quot;a: &quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;a+1 :&quot;&lt;&lt;a+1&lt;&lt;endl; cout&lt;&lt;&quot;*a: &quot;&lt;&lt;*a&lt;&lt;endl; cout&lt;&lt;&quot;*a+1 :&quot;&lt;&lt;*a+1&lt;&lt;endl; cout&lt;&lt;&quot;a[0]: &quot;&lt;&lt;a[0]&lt;&lt;endl; cout&lt;&lt;&quot;a[1]: &quot;&lt;&lt;a[1]&lt;&lt;endl; cout&lt;&lt;&quot;a[0]+1: &quot;&lt;&lt;a[0]+1&lt;&lt;endl; cout&lt;&lt;&quot;(a+1)[0] :&quot;&lt;&lt;(a+1)[0]&lt;&lt;endl; cout&lt;&lt;&quot;——————————————————————&quot;&lt;&lt;endl; cout&lt;&lt;&quot;*(a+1) :&quot;&lt;&lt;*(a+1)&lt;&lt;endl; cout&lt;&lt;&quot;*(*a+1) :&quot;&lt;&lt;*(*a+1)&lt;&lt;endl; cout&lt;&lt;&quot;*a[1]: &quot;&lt;&lt;*a[1]&lt;&lt;endl; cout&lt;&lt;&quot;——————————————————————&quot;&lt;&lt;endl; cout&lt;&lt;&quot;(*a)[1] :&quot;&lt;&lt;(*a)[1]&lt;&lt;endl; cout&lt;&lt;&quot;*(a+1)[1] :&quot;&lt;&lt;*(a+1)[1]&lt;&lt;endl; cout&lt;&lt;&quot;(*a+1)[0] :&quot;&lt;&lt;(*a+1)[0]&lt;&lt;endl; cout&lt;&lt;&quot;——————————————————————&quot;&lt;&lt;endl; cout&lt;&lt;&quot;**a&quot;&lt;&lt;**a&lt;&lt;endl; } 运行结果 解释 指针不光代表地址值标量，还蕴含其变化范围属性(反映其所指对象所占内存大小) –dereference操作,会将a退化为整形指针(变化范围每次1个字节，即04H)。 [] –加上偏移量后再做dereference操作 ()[] –[]的优先级高于,先偏移N个( )指针单位 , 再对( )做dereference操作(取指针对象的值）。 指向包含5个整型元素数组的指针 (变化范围每次20个字节，即14H)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[this详解]]></title>
      <url>%2F2017%2F03%2F09%2Fthis%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[this在Java中的几种用法this关键字必须放在非静态方法中，代表自身。 几种用法引用成员变量在一个类的方法或者构造方法内部，可用this.成员变量名来引用成员变量。如果变量名不发生重叠，则this可以省略。 例子public class Test { private int a; public Test(int a) { this.a = a; } public int getA() { return a; } public void setA(int a) { this.a = a; } } 引用构造方法在一个类的构造方法内部，也可以使用this关键字引用其它的构造方法，这样可以降低代码的重复，也可以使所有的构造方法保持统一，这样方便以后的代码修改和维护，也方便代码的阅读。 例子public class Test { int a; public Test(int a) { this.a = a; } public Test(int c, boolean b) { this(c); } } 注意事项 当一个类内部的构造方法比较多时，可以只书写一个构造方法的内部功能代码，然后其它的构造方法都通过调用该构造方法实现，这样既保证了所有的构造是统一的，也降低了代码的重复。 在实际使用时，需要注意的是，在构造方法内部使用this关键字调用其它的构造方法时，调用的代码只能出现在构造方法内部的第一行可执行代码。代表自身对象可以用this代表自身类的对象，每个类中有一个隐含成员变量，变量类型为该类的类型。例子 public class Test {Test instance; public Test() { instance = this; } public void test() { System.out.println(this); } }由于这个原因，在类的内部成员方法之间的相互调用可以采用this.方法名。 参考资料http://blog.csdn.net/javaniuniu/article/details/52447502]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[StackandQueue]]></title>
      <url>%2F2017%2F03%2F04%2FStackandQueue%2F</url>
      <content type="text"><![CDATA[栈基本概念怎么说呢，栈就是一种特殊的线性表，线性表的删除与插入可以在任意位置进行，而栈只允许在一端进行，允许操作的是栈顶，不允许操作的是栈底，是先进后出。把握好top即可。 一些特点top很关键:表示栈顶元素的位置。top=0，指向栈顶元素的下一个存储位置。top=-1,指向栈顶元素存储位置。代码均采用top等于0来测试即指向栈顶元素的下一个存储位置。 按实现方式来进行分类顺序栈用连续的空间来存放元素，用数组来实现。需要注意的是栈的存储单元maxSize与top之间的关系maxSize&gt;=top。其实顺序栈特别的简单就把握住一下4点即可。 1. 栈空的条件时top=0. 2. 栈满的条件时top=stackElem.length=maxSize 3. 栈顶元素是stackElem[top-1] 4. 栈的长度为top 图示形成入栈 判断栈是否满，满则抛出异常，不满去2. 将新元素放在top位置上 top加1 public void push(Object x) throws Exception { //没有考虑到栈满的情况 if(top==stackElem.length) throw new Exception(&quot;栈已经满&quot;); stackElem[top]=x; top++; } 出栈 public Object pop() throws Exception { //出栈需要返回栈顶元素stackElem[top-1]=null;top--还要记得判断栈是不是为空 if (top == 0) return null; return stackElem [--top]; } 查询某一个索引的元素查询某一个元素的索引遍历输出置空栈中元素个数链栈图示形成输出栈的长度入栈出栈查询某一个索引的元素查询某一个元素的索引遍历输出置空]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sort]]></title>
      <url>%2F2017%2F03%2F04%2Fsort%2F</url>
      <content type="text"><![CDATA[这次主要是总结一下排序的相关知识 定义将一组无序的记录序列调整为有序的记录序列的一种操作。 关键字是数据元素中某个数据项的值，用以标识一个数据元素。有主关键字，次关键字。 稳定排序相同的关键字的记录(Ki=kj),在排序前（Ri&lt;Rj),排序后Ri&lt;Rj,则是稳定的。 不稳定排序]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebService]]></title>
      <url>%2F2017%2F03%2F04%2FWebService%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSM框架整合]]></title>
      <url>%2F2017%2F03%2F04%2FSSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[LengthandSize]]></title>
      <url>%2F2017%2F03%2F04%2FLengthandSize%2F</url>
      <content type="text"><![CDATA[length,length()与size()的区别 java中的length属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了length这个属。 java中的length()方法是针对字符串String说的,如果想看这个字符串的长度则用到length()这个方法. java中的size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看! 一个示例public static void main(String[] args) { int [] list={1,2,3,4,5}; String a=&quot;macaoyuan&quot;; System.out.println(list.length); System.out.println(a.length()); List&lt;Object&gt; array=new ArrayList(); array.add(a); System.out.println(array.size()); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UML]]></title>
      <url>%2F2017%2F02%2F24%2FUML%2F</url>
      <content type="text"><![CDATA[在UML图中常见的有以下几种关系,泛化，实现，关联，聚合，组合，依赖。 泛化关系定义是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。 表示方法带三角箭头的实线，箭头指向父类 实现关系定义是一种类与接口的关系，表示类是接口所有特征和行为的实现. 表示方法带三角箭头的虚线，箭头指向接口 关联关系定义是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。 表示方法带普通箭头的实心线，指向被拥有者 聚合关系定义是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。 表示方法带空心菱形的实心线加普通箭头，菱形指向整体 组合关系定义是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期 表示方法带实心菱形的实线加普通箭头，菱形指向整体 依赖关系定义是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.比如人与计算机 表示方法带普通箭头的虚线，指向被使用者 各种关系的强弱顺序泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 展示各类关系[img](/images/UML.png)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SearchS]]></title>
      <url>%2F2017%2F02%2F24%2FSearchS%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tree]]></title>
      <url>%2F2017%2F02%2F24%2FTree%2F</url>
      <content type="text"><![CDATA[可以用树一种表示元素与逻辑关系。树是由n&gt;=0个节点构成的有限集合，n&gt;0时结点必须满足有且仅有一个根节点，其余结点又可以分层m(m&gt;0)个集合，每个集合都是一棵树。 一些基本概念分类二叉树基本概念一些性质二叉树的链式存储结构既然是链式存储，那一定会有结点类，链式本来就是元素+指针。 结点类部分展示private Object data; private BiTreeNode rchild,lchild; public BiTreeNode() { this(null); } public BiTreeNode(Object data) { this(data,null,null); } public BiTreeNode(Object data, BiTreeNode rchild, BiTreeNode lchild) { this.data = data; this.rchild = rchild; this.lchild = lchild; } 建立遍历增删查长度判断是否为空#### 满二叉树完全二叉树平衡二叉树（Huffman树）二叉搜索树高度平衡]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LinearList]]></title>
      <url>%2F2017%2F02%2F24%2FLinearList%2F</url>
      <content type="text"><![CDATA[按元素之间的逻辑关系不同可以分为线性表，图，树，集合。之前分析了集合，接下来会一次分析那几个。 线性表 定义线性表就是n个元素（n&gt;=0)构成的有限序列。线性表中第一个元素的存储地址为线性表的起始地址，称为头指针，若果有头结点，头结点没有数据，指向头结点的指针称为头指针。关键就是把握好头指针，以及是否有头结点。 一些基本概念 同类型的元素组成 线性表只是一种逻辑结构，其具体存储结构可以分为顺序存储结构和链式储存结构来完成,可以得到顺序表和链表。 对线性表的入表和出表顺序做一定的限定，可以得到特殊的线性表，栈(FILO)和队列（FIFO）分类顺序表基本概念 由地址连续的存储单元依次存放线性表中的数据。 基地址：线性表的起始地址。 地址计算公式loc(i)=loc(0)+(i-1)*C=LOC(i-1)+C一些基本操作图示形成插入在第i个元素前插入 public void insert(int i, Object x) throws Exception{ if(curLen == listElem.length) throw new Exception(&quot;顺序表已经满了&quot;); if(i&lt;0 || i&gt;curLen) throw new Exception(&quot;插入位置不合理&quot;); for(int j=curLen;j&gt;i;j--) { listElem[j]=listElem[j-1]; } listElem[i]=x; curLen++; } 删除删除第i个元素 public void remove(int i) throws Exception{ if(i&lt;0 || i&gt;curLen-1) throw new Exception(&quot;删除位置不合理&quot;); for(int j=i;j&lt;curLen-1;j++) { listElem[j]=listElem[j+1]; } curLen--; } 查询某一个索引的元素 public Object get(int i) throws Exception{ if(i&lt;0||i&gt;curLen-1) throw new Exception(&quot;第&quot; + i + &quot;个元素不存在&quot;); return listElem[i]; } 查询某一个元素的索引 public int indexOf(Object x) { int j=0; while(j&lt;curLen&amp;&amp;x!=listElem[j]) { j++; if(j&gt;curLen-1) System.out.println(&quot;元素不存在&quot;); } return 0; } 遍历输出 public void display(){ for (int j = 0; j &lt; curLen; j++) System.out.print(listElem[j] + &quot; &quot;); System.out.println();// 换行 } 置空 public void clear() { curLen=0; } 输出表的长度 public int length() { return curLen; } 判断当前线性表中元素个数是否为0 public boolean isEmpty() { if(curLen==0) return true; return false; } 优缺点支持随机访问；空间利用率高（连续分配，不存在空间浪费）大小固定（一开始就要固定顺序表的最大长度）；插入和删除元素需要移动大量的数据顺序表效率分析 其他插入操作：移动元素时，要从后往前操作，不能从前往后操作，不然元素会被覆盖的。删除元素：移动元素时，要从前往后操作。 应用举例链表基本概念用一组地址任意的存储单元来存线性表中的元素。用结点（数据域+指针）的序列来表示。这个指针指向列表中的下一个节点，而最后一个节点则指向一个空值 分类有头结点单链表 头指针：线性表中第一个元素的存储地址。 头结点：头结点的数据域可以不存储任何信息，也可以存储如线性表长度等类的附加信息，头结点的指针域存储指向第一个结点的指针。这时头指针指向头结点的位置。 什么时候单链表为空，头结点的指针域为空或是当前的表长度为0。结点类的描述: private Object data; private MNode next; 一些基本操作图示形成可以通过头插法、尾插法来插入形成一个带有头结点的单链表 private void create2(int n) throws Exception { //其实可以采用传参的形式，这里借鉴那个采用输入,，由于需要一个结束循环的，所以n代表链表的长度 Scanner sc=new Scanner(System.in); for (int m = 0; m&lt; n; m++) { insert(0,sc.next()); } } public void create1(int n) throws Exception { Scanner sc=new Scanner(System.in); for (int m1 = 0; m1&lt; n; m1++) insert(m1,sc.next()); } 插入a. 找到第i个结点的前驱b.将新的结点的后继指向第i个结点c.将前驱的后继指向新结点 public void insert(int i, Object x) throws Exception { MNode p=head; int j=-1; while(p != null &amp;&amp; j &lt; i - 1) { p=p.getNext(); j++; } if (j &gt; i - 1 || p == null) // i不合法 throw new Exception(&quot;插入位置不合理&quot;);// 输出异常 MNode s=new MNode(x,p); s.setNext(p.getNext()); p.setNext(s); } 删除查询某一个索引的元素查询某一个元素的索引遍历输出置空输出表的长度无头结点的单链表一些基本操作图示形成插入头插法尾插法 删除查询某一个索引的元素查询某一个元素的索引遍历输出置空输出表的长度双链表一些基本操作图示形成插入头插法尾插法 删除查询某一个索引的元素查询某一个元素的索引遍历输出置空输出表的长度循环列表一些基本操作图示形成插入头插法尾插法 删除查询某一个索引的元素查询某一个元素的索引遍历输出置空输出表的长度栈基本概念 由地址连续的存储单元依次存放线性表中的数据。 基地址：线性表的起始地址。 地址计算公式一些特点一些基本操作图示形成插入删除查询某一个索引的元素查询某一个元素的索引遍历输出置空输出表的长度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaDesign]]></title>
      <url>%2F2017%2F02%2F23%2FJavaDesign%2F</url>
      <content type="text"><![CDATA[23种设计模式总结特别喜欢这句话，招式与内功哪个更重要，Java、C#、C++等编程语言，Eclipse、Visual Studio等开发工具，JSP、ASP.net等开发技术，Struts、Hibernate等框架技术，所有这些我们都可以认为是招式;而数据结构、算法、设计模式、重构、软件工程等则为内功。招式可以很快学会，但是内功的修炼需要更长的时间。 常用设计模式一览表创建型模式 结构型模式 行为型模式 7种面向对象设计原则 策略模式参考资料 Head First 设计模式 网上的其他资料]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybatis]]></title>
      <url>%2F2017%2F02%2F23%2FMybatis%2F</url>
      <content type="text"><![CDATA[Mybatis是一个半自动映射的框架，需要手工匹配提供POJO,SQL和映射关系，而Hibernate只需要提供POJO与映射关系即可。 基本构成SqlSessionFactoryBuilder(构造器)：根据配置信息或者代码来生成SQLSessionFactory。SqlsessionFactory(工厂接口)：依靠这个工厂来生成sqlsession。Sqlsession(会话）：可以发送SQL去执行并返回结果，也可以获取Mapper接口。SQL Mapper:由一个JAva接口和XML文件构成的，负责发送SQL去执行，并返回结果。 Mybatis的构成.png 第一个Mybatis应用构建SqlsessionFactory 可以通过XML配置方式来构建 通过代码来构建使用XML的方式来构建 获取数据库连接实例的数据源DataSource 事物管理器（决定事物范围以及控制方式） SQL Mapper &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;configuration&gt;&lt;!--配置--&gt; &lt;properties/&gt;&lt;!--属性--&gt; &lt;settings/&gt;&lt;!--设置--&gt; &lt;typeAliases/&gt;&lt;!--类型命名--&gt; &lt;typeHandlers/&gt;&lt;!--类型处理器--&gt; &lt;objectFactory/&gt;&lt;!--对象工厂--&gt; &lt;plugins/&gt;&lt;!--插件--&gt; &lt;environments/&gt;&lt;!--配置环境--&gt; &lt;environment/&gt;&lt;!--环境变量--&gt; &lt;transactionManager/&gt;&lt;!--事务管理器--&gt; &lt;datasourse/&gt;&lt;!--数据源--&gt; &lt;enviroment/&gt; &lt;environments/&gt; &lt;databaseIdProvider/&gt;&lt;!--数据库厂商标识--&gt; &lt;mappers/&gt;&lt;!--映射器--&gt; &lt;/configuration&gt; Mapper映射器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SpringMvc]]></title>
      <url>%2F2017%2F02%2F23%2FSpringMvc%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring]]></title>
      <url>%2F2017%2F02%2F23%2FSpring%2F</url>
      <content type="text"><![CDATA[Spring 采用以下4种关键策略 基于POJO的轻量级和最小侵入性编程 通过依赖注入与面向接口实现松耦合 基于切面与惯例进行声明式编程 通过切面和模板减少样板式代码装配beanSpring 容器负责创建应用程序中的bean并通过DI来协调这些对象之间的关系。有3种装配bean的方式。 在XML中进行显示配置 在java中进行显示配置 隐式的bean发现机制与自动装配(组件扫描+自动装配）自动装配自动装配就是一个组件扫描（找到bean)+自动装配（找到bean之间的依赖关系）举例说明CD与CD播放器的例子两个beanjava中显示配置 JavaConfig @Configuration :表明该类是一个配置类，包含Spring在上下文中如何创建bean。 @Bean：使用该注解的方法将返回一个对象，该对象要注册成为Spring应用上下文的bean。 怎么进行装配：采用构造器或者Setter return new CDPlayer(compactDisc); 自动装配 @Component：这个注解表明该类会作为组件类，并且告诉Spring要为这个类创建Bean。（组件扫描默认是不启用的，需要配置，这样才会去找@Component，进而为其创建bean。)怎么开启： @ComponentScan 该注解会在Spring中启用组件扫描，默认扫描与配置类相同的包。&lt;context:Component-scan base-package=&quot;com.beanStudyAuto&quot;&gt; @Autowired 默认按类型匹配,自动装配(Srping提供的)在XML中进行显示配置声明借助构造器初始化 ref,创建爱你一个CDplayer实例，然后将id为compactDisc的bean引用传递到CDplayer的构造器中。设置属性来看看IOC与DI一直以来对这两个概念十分的模糊。起初觉得这两个是一样的，其实不是。DIPIOC DI是什么为什么如果没有DI的话代码将会非常的耦合，高层模块（被依赖对象）的实现依赖于低层模块（依赖对象），没有IOC,我们将在被依赖的模块类中直接同过new来进行依赖。这种方式有几个缺点举个例子： public class SqlserverManger { //连接SQLserver数据库 //在数据库中插入一条数据 public void insert() { System.out.println(&quot;在数据库中添加一条订单!&quot;); } } public class Order { SqlserverManger sqlm=new SqlserverManger(); //添加商品的逻辑 public void add() { sqlm.insert(); System.out.println(&quot;所有的逻辑处理已经完成&quot;); } } public class Controller { public static void main(String[] args) { Order order=new Order(); order.add(); } } 如果需要更换数据库的时候，无论是修改SqlserverManger这个类，还是在增加另个一数据库的处理类，都需要修改一部分代码。（DAo+service+Controller) 怎么实现构造器public interface SqlManger { void insert(); } //再增加一个Oracle的 public class oracleManger implements SqlManger { //连接oracle数据库 //在数据库中插入一条数据 public void insert() { System.out.println(&quot;在oracle数据库中添加一条订单!&quot;); } } public class order2 { private SqlManger sqlmanger; public order2(SqlManger sqlmanger) { this.sqlmanger=sqlmanger; } public void add() { sqlmanger.insert(); System.out.println(&quot;所有的逻辑处理已经完成&quot;); } } SqlserverManger sqlm=new SqlserverManger(); oracleManger oracle=new oracleManger(); order2 order=new order2(sqlm); order.add(); order2 ordert=new order2(oracle); ordert.add(); setter注入构造器方法注入接口注入## AOP术语 通知 连接点 切点 前面 引入 Spring提供了4种类型的AOP支持 基于代理的经典Spring AOP 纯POJO切面 @AspectJ注解驱动的切面 注入式AspectJ切面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[thread]]></title>
      <url>%2F2017%2F02%2F20%2Fthread%2F</url>
      <content type="text"><![CDATA[在 Java 语言中使用多线程要远比在C++ 中来得简单。 在操作系统中两个比较容易混淆的概念是进程（process）和线程（thread）。 一些小的概念 进程:计算机中特定功能的程序在数据集上的一次运行。（电脑的任务管理器里面有很多进程） 线程：进程的一个单元。（视频播放器） 多线程：一个进程里面有多个线程在同时进行。（迅雷下载） 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。 java虚拟机是多线程，有垃圾回收机制清理没有被引用的对象。 共享资源：可以被一个以上任务使用的资源叫做共享资源。为了防止数据被破坏，每个任务在与共享资源打交道时，必须独占该资源。 同步(Synchronized)：服务器执行任务必须等上一个任务执行完后，才执行下一个任务。 对于并发安全性 生产者：有水果就不生产，消费者买走后通知生产者，生产者去生产。 消费者：没有水果就等待，生产者生产出通知，消费者去买。线程的生命周期线程的生命周期.png新建 线程被new出来。 处于创建状态的线程只是一个空的线程对象，系统不为它分配资源。就绪 具有执行的资格，没有执行的权利，即线程调用了start()方法，但是这个时候不一定是运行状态（不一定可以抢占到CPU资源）运行 具备执行的资格与权利阻塞 没有执行的资格与权利。 当发生下列事件时，处于运行状态的线程会转入到不可运行状态： 调用了sleep()方法； 线程调用wait()方法等待特定条件的满足； 线程输入/输出阻塞。 发生下列事件时返回可运行状态： 处于睡眠状态的线程在指定的时间过去后； 如果线程在等待某一条件，另一个对象必须通过notify()或notifyAll()方法通知等待线程条件的改变； 等待输入输出完成。 销毁 当线程的run()方法执行结束或这是调用了stop()方法，释放资源。实现 通过Thread类，将类声明为Thread的子类，该子类重写Thread类的run方法，接下来分配并启动该子例的实例，然后通过实例启动线程（这里不是单纯的调用run方法，这样并不是在执行多线程。start）。 public class ThreadDemo extends Thread { @Override public void run() { for(int i=0;i&lt;50;i++) { System.out.println(this.getName()+&quot;hello&quot;+i); } } } //创建线程的示例对象 ThreadDemo thr=new ThreadDemo(); ThreadDemo thr1=new ThreadDemo(); thr.start(); thr1.start(); 声明实现Ruunable接口的类，然后该类实现run方法。然后分配该类的实例，在创建线程时作为一个参数来传递 public class ThreadSecond implements Runnable { @Override public void run() { for(int i=0;i&lt;50;i++) { System.out.println(Thread.currentThread().getName()+&quot;hello&quot;+i); } } } ThreadSecond th1=new ThreadSecond(); Thread t1 =new Thread(th1,&quot;线程1&quot;); ThreadSecond th2=new ThreadSecond(); Thread t2=new Thread(th2); t1.start(); t2.start(); getName是Thread的方法，第一种方法是继承Thread类，所以可以调用父类的方法，但是第二种是实现Ruunable接口，故没有该方法。(Thread.currentThread(),通过这个得到当前的线程）ThreadRuunable.png 如果一个类在使用多线程时已经继承了一个类（Java是单线程的），这个时候再去继承Thread就是不现实的了。 以上多线程的实现是并发的，这几个线程在不停的相互抢占CPU资源。并发安全性SynchronizedSynchronized(锁对象————是一个共享对象）{ //操作共享资源的代码（同步代码块）}同步代码加在什么地方？ 代码被多个线程使用 代码中有共享的数据。 共享数据被多条语句使用。Synchronized同步代码块的锁对象可以是任意类对象（线程的实现方式是继承Thread）这个对象必须是线程类共享（静态的） 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[exception]]></title>
      <url>%2F2017%2F02%2F20%2Fexception%2F</url>
      <content type="text"><![CDATA[本文主要是深入理解一下Java异常处理机制。异常指不期而至的各种状况，Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的错误条件。 java异常类层次结构图![img](/images/java异常类层次结构图.jpg) Error表示运行应用程序中较严重问题,大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题,出现这种情况你唯一能做的就是听之任之，交由JVM来处理，不过JVM在大多数情况下会选择终止线程。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。 Exception是应用程序中可能的可预测、可恢复问题。一般大多数异常表示中度到轻度的问题。异常一般是在特定环境下产生的，通常出现在代码的特定方法和操作中。Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。 运行时异常都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。 非运行时异常 （编译异常）是RuntimeException以外的异常，从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。 Java 异常分类Java 异常可分为可检测异常，非检测异常和自定义异常。 可检测异常可检测异常经编译器验证，对于声明抛出异常的任何方法，编译器将强制执行处理或声明规则，例如：sqlExecption 这个异常就是一个检测异常。你连接 JDBC 时，不捕捉这个异常，编译器就通不过，不允许编译。 非检测异常非检测异常不遵循处理或声明规则。在产生此类异常时，不一定非要采取任何适当操作，编译器不会检查是否已解决了这样一个异常。例如：一个数组为 3 个长度，当你使用下标为３时，就会产生数组下标越界异常。这个异常 JVM 不会进行检测，要靠程序员来判断。有两个主要类定义非检测异常：RuntimeException 和 Error。 自定义异常自定义异常是为了表示应用程序的一些错误类型，为代码可能发生的一个或多个问题提供新含义。 一个测试代码package exception; public class TestException { public TestException() { } boolean testEx() throws Exception { boolean ret = true; try { ret = testEx1(); } catch (Exception e) { System.out.println(&quot;testEx, catch exception&quot;); ret = false; throw e; } finally { System.out.println(&quot;testEx, finally; return value=&quot; + ret); return ret; } } boolean testEx1() throws Exception { boolean ret = true; try { ret = testEx2(); if (!ret) { return false; } System.out.println(&quot;testEx1, at the end of try&quot;); return ret; } catch (Exception e) { System.out.println(&quot;testEx1, catch exception&quot;); ret = false; throw e; } finally { System.out.println(&quot;testEx1, finally; return value=&quot; + ret); return ret; } } boolean testEx2() throws Exception { boolean ret = true; try { int b = 12; int c; for (int i = 2; i &gt;= -2; i--) { c = b / i; System.out.println(&quot;i=&quot; + i); } return true; } catch (Exception e) { System.out.println(&quot;testEx2, catch exception&quot;); ret = false; throw e; } finally { System.out.println(&quot;testEx2, finally; return value=&quot; + ret); return ret; } } public static void main(String[] args) { TestException testException1 = new TestException(); try { testException1.testEx(); } catch (Exception e) { e.printStackTrace(); } } } 运行结果i=2 i=1 testEx2, catch exception testEx2, finally; return value=false testEx1, finally; return value=false testEx, finally; return value=false 分析testEx()的try调用testEx1(),testEx1()的try调用testEx2(),12/2,12/1,12/0异常，执行testEx2()的catch,然后执行testEx2()的finally,接着执行testEx1()的finally,最后执行testEx()的finally。需要注意的是在testEx2()catch后并没有执行testEx1()的catch。 Java 异常的处理在 Java 应用程序中，对异常的处理有两种方式：处理异常和声明异常。 参考资料 http://blog.csdn.net/hguisu/article/details/6155636 Java核心技术I]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[refelection]]></title>
      <url>%2F2017%2F02%2F20%2Frefelection%2F</url>
      <content type="text"><![CDATA[总结一下反射 对象的类型对象有编译与运行类型 Object obj = new Date(); 编译类型:Object运行类型(其实就是obj对象真实的类型):Date如果说obj去调用Date中的一个方法的话，编译的时候会去看Object中是否有这个方法，没有的话就会编译失败。 解决方案 强制类型转换（必须知道真实类型） Date d = (Date)obj; 利用反射反射的定义元数据描述数据的描述数据（对象是数据，类是描述数据，描述类的是Class,描述数据的描述数据）反射.png]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[variable]]></title>
      <url>%2F2017%2F02%2F19%2Fvariable%2F</url>
      <content type="text"><![CDATA[Java 中的成员变量、局部变量、静态变量、类变量、非静态变量、实例变量。在Java中变量大致上可以分为成员变量与局部变量两大类。 全局变量全局变量也叫成员变量 在类里面定义的变量称为成员变量。 如果前面有static修饰，则该成员变量为静态变量或者类变量。 如果前面无static修饰，则该成员变量为非静态变量或实例变量。 全局变量不需要初始化。 存在于堆内存中。 静态变量静态全局变量 静态全局变量的定义静态的类成员变量 生存时间静态全局变量随着类的字节码文件加载而加载产生，随着字节码文件的消失而消失，生存时间比类的对象还要长； 是否初始化凡是全局变量都是可以不要初始化的，静态变量也是一样，系统会自动根据其数据类型进行赋默认值，但是建议变量在声明时都进行初始化； 创建位置静态变量是存在于堆内存中的，所以静态全局变量也是存在于堆内存中的。 类变量不依赖类的实例，类变量只在初始化时候在栈内存中被分配一次空间，无论类的实例被创建几次，都不再为类变量分配空间，即而且所有对象的同一个类变量都是共享同一块内存空间的 通过类的任意一个实例来访问类变量，底层都将将其转为通过类本身来访问类变量，它们的效果是一样的 一旦类变量的值被改变，通过类或类的任意一个实例来访问类变量，得到的都将是被改变后的值 将在类的初始化之前初始化 非静态变量非静态全局变量的定义非静态全局变量都是定在类中，是类的成员变量或者说是成员属性属于类的一部分（或 者说是对象的一部分）； 生存时间非静态全局变量加载在堆内存中，随着声明初始化而创建，随着对象消亡而消亡； 是否需要初始化全局变量都是不需要被强制初始化的，系统都会默认根据其数据类型进行默认赋值；但是建议在声明时都进行初始化操作； 创建位置创建在堆内存中，因为非静态的全局变量数对象的成员变量是对象的一部分； 变量属于类的实例对象 随着类的实例被创建而分配内存空间。 局部变量形参、方法内定义的变量、代码块中定义的变量。 生存时间局部变量的生存时间和方法的生存时间一致，调用该方法声明该局部变量并初始化的时，该局部变量被创建并分配内存空间；直到该方法调用结束局部变量也就结束了； 是否需要初始化局部变量在使用前必须进行初始化，系统默认不会对局部变量进行初始化数据操作，如果局部 变量在使用前没有进行初始化则会在编译器报错；如果局部变量进行了声明没有进行初始化， 但是也一直没有被使用的话编译也是不会报错的；（局部变量使用前必须初始化话） 创建位置局部变量是创建在栈内存中的 在使用变量时需要遵循的原则就近原则 代码测试 package variable; public class test { int count = 0; //类成员变量计数器 static int sum = 0; //静态变量计数器 String name=&quot;类中的成员变量&quot;; test(String name) { this.name = name; } test() { } public void mytest() { count++; System.out.println(name+&quot;调用非静态成员变量的值：&quot;+count); } public void staticmytest() { sum++; System.out.println(name+&quot;调用静态成员变量的值：&quot;+sum); } public void test1() { //int count=20; System.out.println(++count); } public void test2() { String name =&quot;类体方法中定义的name&quot;; //在方法speak中定义和成员变量名字相同的name并赋值 System.out.println(name); System.out.println(this.name); //通过this来访问类中的成员变量 } public void testtime() { count++; sum++; System.out.println(&quot;count的值：&quot;+count); System.out.println(&quot;sum的值：&quot;+sum); } public static void main(String[] args) { test mtest=new test(&quot;对象1&quot;); test mtest2=new test(&quot;对象2&quot;); System.out.println(&quot;测试不同的对象调用非静态变量&quot;); mtest.mytest(); mtest.mytest(); mtest2.mytest(); System.out.println(&quot;同一个对象多次调用同一非静态变量会累加，不同对象调用会重新初始化&quot;); System.out.println(&quot;——————————————————————&quot;); System.out.println(&quot;测试不同的对象调用非静态变量&quot;); mtest.staticmytest(); mtest2.staticmytest(); mtest2.staticmytest(); System.out.println(&quot;同一个对象多次调用同一非静态变量会累加，不同对象调用也会累加，应为共享内存&quot;); System.out.println(&quot;——————————————————————&quot;); System.out.println(&quot;测试同一个对象调用同一个方法中的局部变量&quot;); test mtest3=new test(); mtest3.test1(); mtest3.test1(); System.out.println(&quot;同名时会就近，局部变量不会累加，离开方法就无效&quot;); System.out.println(&quot;——————————————————————&quot;); System.out.println(&quot;测试在方法中对同名的成员变量与局部变量的访问&quot;); mtest3.test2(); mtest.test2(); System.out.println(&quot;通过this来访问类中的成员变量 &quot;); System.out.println(&quot;——————————————————————&quot;); System.out.println(&quot;测试同一对象调用静态成员与非静态成员&quot;); mtest3.testtime(); mtest3.mytest(); mtest3.testtime(); System.out.println(&quot;——————————————————————&quot;); } } 输出结果 测试不同的对象调用非静态变量 对象1调用非静态成员变量的值：1 对象1调用非静态成员变量的值：2 对象2调用非静态成员变量的值：1 同一个对象多次调用同一非静态变量会累加，不同对象调用会重新初始化 —————————————————————— 测试不同的对象调用非静态变量 对象1调用静态成员变量的值：1 对象2调用静态成员变量的值：2 对象2调用静态成员变量的值：3 同一个对象多次调用同一非静态变量会累加，不同对象调用也会累加，应为共享内存 —————————————————————— 测试同一个对象调用同一个方法中的局部变量 1 2 同名时会就近，局部变量不会累加，离开方法就无效 —————————————————————— 测试在方法中对同名的成员变量与局部变量的访问 类体方法中定义的name 类中的成员变量 类体方法中定义的name 对象1 通过this来访问类中的成员变量 —————————————————————— 测试同一对象调用静态成员与非静态成员 count的值：3 sum的值：4 类中的成员变量调用非静态成员变量的值：4 count的值：5 sum的值：5 ——————————————————————]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[extends]]></title>
      <url>%2F2017%2F02%2F19%2Fextends%2F</url>
      <content type="text"><![CDATA[这次主要分析一下类的关键字 extendsextends表示的是继承，孩子类继承父类，子类继承超类，继承是一种is-a的关系。 示例public class Manager extends Employee() { } 子类可以重写父类的方法（覆盖）这里需要注意，如果子类中重写的这个方法也要用到父类中同名的方法，可以用到super.getSalary() 多态一个对象变量可以指示多种实际类型的现象为多态。 final不允许扩展的类称为final类，即final类不能定义子类。同样子类不能覆盖的方法叫做final方法 final类示例public final class Manager extends Employee() { } final方法示例public class test { public final String getName() { } } final变量（实例变量，静态变量，常量）示例public class finalTest { private final String S = &quot;final实例变量S&quot;; private final int A = 100; public final int B = 90; public static final int C = 80; //同static一起定义常量 private static final int D = 70; public final int E; //final空白,必须在初始化对象的时候赋初值 public finalTest(int x) { E = x; } /** * @param args */ public static void main(String[] args) { finalTest t = new finalTest(2); //t.A=101; //出错,final变量的值一旦给定就无法改变 //t.B=91; //出错,final变量的值一旦给定就无法改变 //t.C=81; //出错,final变量的值一旦给定就无法改变 //t.D=71; //出错,final变量的值一旦给定就无法改变 System.out.println(t.A); System.out.println(t.B); System.out.println(t.C); //不推荐用对象方式访问静态字段 System.out.println(t.D); //不推荐用对象方式访问静态字段 System.out.println(finalTest.C); System.out.println(finalTest.D); //System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. System.out.println(t.E); finalTest t1 = new finalTest(3); System.out.println(t1.E); //final空白变量E依据对象的不同而不同 } } abstract抽象类包含一个或多个抽象方法的类必须被声明为抽象的。在子类中都有必要的操作要进行，但是在超类中却没有什么相关操作需要进行的方法为抽象方法,具体的实现在子类。 示例public abstract class Person { private String name; public Person(String name) { this.name=name; } public abstract String getDescription(); } 一些注意的地方 abstract不能被实例化，即不能创建这个类的对象，但是可以创建一个具体子类的对象。只能引用非抽象子类的对象。 扩展抽象类有两种方法：抽象类中定义部分或者不定义抽象类方法，子类也为abstract类。 抽象类中定义全部抽象方法，子类不是abstract类。 abstract 关键字不能应用于 static、private 或 final 方法，因为这些方法不能被重写，因此，不能在子类中实现。 final 类的方法都不能是 abstract，因为 final 类不能有子类。java中的访问权限 private只有本类可见 Protected本包与所有子类可见 public所有类都可以看到 没有修饰符，只对本包可见。default,不能声明变量。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java集合]]></title>
      <url>%2F2017%2F02%2F18%2FCollection%2F</url>
      <content type="text"><![CDATA[Java集合框架为不同类型的集合定义了大量的接口，这里主要讲解Collection接口，Map接口，Iterator接口。 Collection接口Collection集合体系继承树![img](/images/Collection集合体系继承树.jpg) Collection接口定义的常用方法 Set中的数据对象没有顺序且不可以重复。 List中的数据对象有顺序且可以重复。 public class CollectioDemo { public static void main(String[] args) { Collection li=new ArrayList(); System.out.println(li);//tostring()方法 li.add(&quot;fanlili&quot;); li.add(&quot;徐ss&quot;); System.out.println(li); Collection li2=new ArrayList();//将一个集合加入到另一个集合中 li2.add(&quot;kek&quot;); li2.add(&quot;mm&quot;); li2.addAll(li); System.out.println(li2); Collection li3=new ArrayList();//对数字的添加直接做了装箱，其实就是Integer li3.add(1); li3.add(3); li3.add(&quot;既有数值又有字符串&quot;);//一般存储同一类型的数据 System.out.println(li3); System.out.println(&quot;-----------------------删除&quot;); /*li2.clear(); System.out.println(li2);*/ /*li3.remove(1); System.out.println(li3);/*?????li2为什么结果不同？？？*/ /*li2.removeAll(li); System.out.println(li2);*/ System.out.println(&quot;-----------------------是否包含&quot;); boolean isexist=li.contains(&quot;fanlili&quot;); System.out.println(isexist); boolean isexist2=li2.containsAll(li); System.out.println(isexist2); boolean isempty=li2.isEmpty(); System.out.println(isempty); Object[] obarray=li2.toArray();//较为重要的将集合转换为数组 for(int i=0;i&lt;obarray.length;i++) { System.out.println(obarray[i]); } } } 运行结果： [] [fanlili, 徐ss] [kek, mm, fanlili, 徐ss] [1, 3, 既有数值又有字符串] -----------------------删除 -----------------------是否包含 true true false kek mm fanlili 徐ss ListArrrayList常用方法（也有collection的那些方法）public class ListDemo { public static void main(String[] args) { List list=new ArrayList(); list.add(&quot;fanlili&quot;); list.add(&quot;ggg&quot;); list.add(1, &quot;xumeng&quot;);//在哪个后面插 list.add(&quot;fanliliwww&quot;); System.out.println(list); Object ob=list.get(2);//根据索引获取元素 System.out.println(ob); int num=list.size(); //获取list的元素个数 System.out.println(num); ListIterator iter=list.listIterator();//ListIterator功能更加强大 while(iter.hasNext()) { Object obj=iter.next(); System.out.println(obj); } System.out.println(&quot;----------------------------------------&quot;); String str= (String)iter.previous();//实现从后向前遍历 System.out.println(str); int pindex=iter.previousIndex();//previousIndex来指示下一个previous()要读取的元素位置 System.out.println(pindex); } } 运行结果如下： [fanlili, xumeng, ggg, fanliliwww] ggg 4 fanlili xumeng ggg fanliliwww ---------------------------------------- fanliliwww 2 vector常用方法（也有collection的那些方法）public class VectorDemo { public static void main(String[] args) { Vector al=new Vector();//构造一个空向量 al.addElement(1); System.out.println(al); al.addElement(new student(&quot;徐ww&quot;,30)); al.addElement(new student(&quot;樊dd&quot;,88)); al.addElement(new student(&quot;文ww&quot;,30)); System.out.println(al); student stu=(student) al.elementAt(1); System.out.println(stu); } } 运行结果： [1] [1, student [name=徐ww, age=30], student [name=樊dd, age=88], student [name=文dd, age=30]] student [name=徐ww, age=30] LinkedList常用方法 boolean add(E e) 将指定元素添加到此列表的结尾。 void add(int index, E element) 在此列表中指定的位置插入指定的元素。 boolean addAll(Collection&lt;? extends E&gt; c) 添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。 boolean addAll(int index, Collection&lt;? extends E&gt; c) 将指定 collection 中的所有元素从指定位置开始插入此列表。 void addFirst(E e) 将指定元素插入此列表的开头。 void addLast(E e) 将指定元素添加到此列表的结尾。 void clear() 从此列表中移除所有元素。 Object clone() 返回此 LinkedList 的浅表副本。 boolean contains(Object o) 如果此列表包含指定元素，则返回 true。 Iterator&lt;E&gt; descendingIterator() 返回以逆向顺序在此双端队列的元素上进行迭代的迭代器。 E element() 获取但不移除此列表的头（第一个元素）。 E get(int index) 返回此列表中指定位置处的元素。 E getFirst() 返回此列表的第一个元素。 E getLast() 返回此列表的最后一个元素。 int indexOf(Object o) 返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。 int lastIndexOf(Object o) 返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。 ListIterator&lt;E&gt; listIterator(int index) 返回此列表中的元素的列表迭代器（按适当顺序），从列表中指定位置开始。 boolean offer(E e) 将指定元素添加到此列表的末尾（最后一个元素）。 boolean offerFirst(E e) 在此列表的开头插入指定的元素。 boolean offerLast(E e) 在此列表末尾插入指定的元素。 E peek() 获取但不移除此列表的头（第一个元素）。 E peekFirst() 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。 E peekLast() 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。 E poll() 获取并移除此列表的头（第一个元素） E pollFirst() 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。 E pollLast() 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。 E pop() 从此列表所表示的堆栈处弹出一个元素。 void push(E e) 将元素推入此列表所表示的堆栈。 E remove() 获取并移除此列表的头（第一个元素）。 E remove(int index) 移除此列表中指定位置处的元素。 boolean remove(Object o) 从此列表中移除首次出现的指定元素（如果存在）。 E removeFirst() 移除并返回此列表的第一个元素。 boolean removeFirstOccurrence(Object o) 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。 E removeLast() 移除并返回此列表的最后一个元素。 boolean removeLastOccurrence(Object o) 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。 E set(int index, E element) 将此列表中指定位置的元素替换为指定的元素。 int size() 返回此列表的元素数。 Object[] toArray() 返回以适当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组。 &lt;T&gt; T[] toArray(T[] a) 返回以适当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组；返回数组的运行时类型为指定数组的类型。 public class LinkedListDemo { public static void main(String[] args) { stack(); } public static void stack() { LinkedList al=new LinkedList(); al.push(new student(&quot;徐ww&quot;,30)); al.push(new student(&quot;樊dd&quot;,88)); al.push(new student(&quot;文dd&quot;,30)); student stu=(student) al.pop(); System.out.println(&quot;------------------------&quot;); Iterator iter=al.iterator(); while(iter.hasNext()) { //获得集合中的一个元素 Object obj=iter.next(); System.out.println(obj); } } } 运行结果： ------------------------ student [name=樊dd, age=88] student [name=徐ww, age=30] *push元素推入此列表所表示的堆栈，add是将指定元素添加到此列表的结尾。 三者的区别： ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。 LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 插入一个泛型示例*为了创建容器类，有了泛型，用&lt;&gt;括起来，在编译期，是无法知道K和V具体是什么类型，只有在运行时才会真正根据类型来构造和分配内存。 泛型接口 public interface Generator&lt;T&gt; public class FruitGenerator implements Generator&lt;String&gt; FruitGenerator generator = new FruitGenerator(); 泛型类 public class Test&lt;T&gt;{} Test&lt;Object&gt; t = new Test&lt;Object&gt;(); 泛型方法 public static &lt;T&gt; void out(T t) { System.out.println(t); } 结合集合的示例 public interface BaseDao&lt;T&gt; { public void save(T t); public T getT(Integer i); public List&lt;T&gt; listT(); } public class StudentImplDemo implements BaseDao&lt;student&gt; { List&lt;student&gt; sList=new ArrayList&lt;student&gt;(); @Override public void save(student t) { sList.add(t); } @Override public student getT(Integer i) { sList.get(i); return null; } @Override public List&lt;student&gt; listT() { return sList; } } public class studentTest { private static BaseDao&lt;student&gt; basedao=new StudentImplDemo(); public static void main(String[] args) { student s=new student(&quot;xumeng&quot; ,88); student s1=new student(&quot;xumengf&quot; ,80); basedao.save(s); basedao.save(s1); List&lt;student&gt; slist=basedao.listT(); System.out.println(slist); } } Set未完待续]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MavenStudy]]></title>
      <url>%2F2017%2F01%2F30%2FMavenStudy%2F</url>
      <content type="text"><![CDATA[Maven是用来干什么的管理项目的工具下载我的jdk是1.8下载版本为3.3.9配置环境变量配置 maven 环境变量(系统变量)：MAVEN_HOME F:\maven\apache-maven-3.3.9在path中添加：;%MAVEN_HOME%\binmaven 版的helloworldmaven 要用到本地仓库，没有会去联网下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[你好]]></title>
      <url>%2F2017%2F01%2F29%2Ftet%2F</url>
      <content type="text"><![CDATA[首先需要明白在这里怎么发表博客怎么来玩我觉得我们都要这样爱初二呼和扩说扩军多活菌多菌或扩多索扩所扩军多敷或多敷或获付俊福军副扩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test]]></title>
      <url>%2F2017%2F01%2F29%2Ftest%2F</url>
      <content type="text"><![CDATA[hwhwhwhwhwhwhwhwwhwhhwhwhwhwhwwwwwwwww是护手霜上海市jdjdjdjdj是护手霜上海市shh MyButton]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F01%2F25%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Quick Start]]></content>
    </entry>

    
  
  
</search>
