<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[UML]]></title>
      <url>%2F2017%2F02%2F24%2FUML%2F</url>
      <content type="text"><![CDATA[在UML图中常见的有以下几种关系,泛化，实现，关联，聚合，组合，依赖。 泛化关系定义是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。 表示方法带三角箭头的实线，箭头指向父类 实现关系定义是一种类与接口的关系，表示类是接口所有特征和行为的实现. 表示方法带三角箭头的虚线，箭头指向接口 关联关系定义是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。 表示方法带普通箭头的实心线，指向被拥有者 聚合关系定义是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。 表示方法带空心菱形的实心线加普通箭头，菱形指向整体 组合关系定义是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期 表示方法带实心菱形的实线加普通箭头，菱形指向整体 依赖关系定义是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.比如人与计算机 表示方法带普通箭头的虚线，指向被使用者 各种关系的强弱顺序泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 展示各类关系]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SearchS]]></title>
      <url>%2F2017%2F02%2F24%2FSearchS%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tree]]></title>
      <url>%2F2017%2F02%2F24%2FTree%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[LinearList]]></title>
      <url>%2F2017%2F02%2F24%2FLinearList%2F</url>
      <content type="text"><![CDATA[线性表中第一个元素的存储地址为线性表的起始地址，称为头指针，若果有头结点，头结点没有数据，指向头结点的指针称为头指针。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaDesign]]></title>
      <url>%2F2017%2F02%2F23%2FJavaDesign%2F</url>
      <content type="text"><![CDATA[23种设计模式总结特别喜欢这句话，招式与内功哪个更重要，Java、C#、C++等编程语言，Eclipse、Visual Studio等开发工具，JSP、ASP.net等开发技术，Struts、Hibernate等框架技术，所有这些我们都可以认为是招式;而数据结构、算法、设计模式、重构、软件工程等则为内功。招式可以很快学会，但是内功的修炼需要更长的时间。 常用设计模式一览表创建型模式 结构型模式 行为型模式 7种面向对象设计原则 策略模式参考资料 Head First 设计模式 网上的其他资料]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybatis]]></title>
      <url>%2F2017%2F02%2F23%2FMybatis%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[SpringMvc]]></title>
      <url>%2F2017%2F02%2F23%2FSpringMvc%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring]]></title>
      <url>%2F2017%2F02%2F23%2FSpring%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[thread]]></title>
      <url>%2F2017%2F02%2F20%2Fthread%2F</url>
      <content type="text"><![CDATA[在 Java 语言中使用多线程要远比在C++ 中来得简单。 在操作系统中两个比较容易混淆的概念是进程（process）和线程（thread）。 ##]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[exception]]></title>
      <url>%2F2017%2F02%2F20%2Fexception%2F</url>
      <content type="text"><![CDATA[本文主要是深入理解一下Java异常处理机制。异常指不期而至的各种状况，Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的错误条件。 java异常类层次结构图 Error表示运行应用程序中较严重问题,大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题,出现这种情况你唯一能做的就是听之任之，交由JVM来处理，不过JVM在大多数情况下会选择终止线程。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。 Exception是应用程序中可能的可预测、可恢复问题。一般大多数异常表示中度到轻度的问题。异常一般是在特定环境下产生的，通常出现在代码的特定方法和操作中。Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。 运行时异常都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。 非运行时异常 （编译异常）是RuntimeException以外的异常，从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。 Java 异常分类Java 异常可分为可检测异常，非检测异常和自定义异常。 可检测异常可检测异常经编译器验证，对于声明抛出异常的任何方法，编译器将强制执行处理或声明规则，例如：sqlExecption 这个异常就是一个检测异常。你连接 JDBC 时，不捕捉这个异常，编译器就通不过，不允许编译。 非检测异常非检测异常不遵循处理或声明规则。在产生此类异常时，不一定非要采取任何适当操作，编译器不会检查是否已解决了这样一个异常。例如：一个数组为 3 个长度，当你使用下标为３时，就会产生数组下标越界异常。这个异常 JVM 不会进行检测，要靠程序员来判断。有两个主要类定义非检测异常：RuntimeException 和 Error。 自定义异常自定义异常是为了表示应用程序的一些错误类型，为代码可能发生的一个或多个问题提供新含义。 一个测试代码package exception; public class TestException { public TestException() { } boolean testEx() throws Exception { boolean ret = true; try { ret = testEx1(); } catch (Exception e) { System.out.println(&quot;testEx, catch exception&quot;); ret = false; throw e; } finally { System.out.println(&quot;testEx, finally; return value=&quot; + ret); return ret; } } boolean testEx1() throws Exception { boolean ret = true; try { ret = testEx2(); if (!ret) { return false; } System.out.println(&quot;testEx1, at the end of try&quot;); return ret; } catch (Exception e) { System.out.println(&quot;testEx1, catch exception&quot;); ret = false; throw e; } finally { System.out.println(&quot;testEx1, finally; return value=&quot; + ret); return ret; } } boolean testEx2() throws Exception { boolean ret = true; try { int b = 12; int c; for (int i = 2; i &gt;= -2; i--) { c = b / i; System.out.println(&quot;i=&quot; + i); } return true; } catch (Exception e) { System.out.println(&quot;testEx2, catch exception&quot;); ret = false; throw e; } finally { System.out.println(&quot;testEx2, finally; return value=&quot; + ret); return ret; } } public static void main(String[] args) { TestException testException1 = new TestException(); try { testException1.testEx(); } catch (Exception e) { e.printStackTrace(); } } } 运行结果i=2 i=1 testEx2, catch exception testEx2, finally; return value=false testEx1, finally; return value=false testEx, finally; return value=false 分析testEx()的try调用testEx1(),testEx1()的try调用testEx2(),12/2,12/1,12/0异常，执行testEx2()的catch,然后执行testEx2()的finally,接着执行testEx1()的finally,最后执行testEx()的finally。需要注意的是在testEx2()catch后并没有执行testEx1()的catch。 Java 异常的处理在 Java 应用程序中，对异常的处理有两种方式：处理异常和声明异常。 参考资料 http://blog.csdn.net/hguisu/article/details/6155636 Java核心技术I]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[refelection]]></title>
      <url>%2F2017%2F02%2F20%2Frefelection%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[variable]]></title>
      <url>%2F2017%2F02%2F19%2Fvariable%2F</url>
      <content type="text"><![CDATA[Java 中的成员变量、局部变量、静态变量、类变量、非静态变量、实例变量。在Java中变量大致上可以分为成员变量与局部变量两大类。 全局变量全局变量也叫成员变量 在类里面定义的变量称为成员变量。 如果前面有static修饰，则该成员变量为静态变量或者类变量。 如果前面无static修饰，则该成员变量为非静态变量或实例变量。 全局变量不需要初始化。 存在于堆内存中。 静态变量静态全局变量 静态全局变量的定义静态的类成员变量 生存时间静态全局变量随着类的字节码文件加载而加载产生，随着字节码文件的消失而消失，生存时间比类的对象还要长； 是否初始化凡是全局变量都是可以不要初始化的，静态变量也是一样，系统会自动根据其数据类型进行赋默认值，但是建议变量在声明时都进行初始化； 创建位置静态变量是存在于堆内存中的，所以静态全局变量也是存在于堆内存中的。 类变量不依赖类的实例，类变量只在初始化时候在栈内存中被分配一次空间，无论类的实例被创建几次，都不再为类变量分配空间，即而且所有对象的同一个类变量都是共享同一块内存空间的 通过类的任意一个实例来访问类变量，底层都将将其转为通过类本身来访问类变量，它们的效果是一样的 一旦类变量的值被改变，通过类或类的任意一个实例来访问类变量，得到的都将是被改变后的值 将在类的初始化之前初始化 非静态变量非静态全局变量的定义非静态全局变量都是定在类中，是类的成员变量或者说是成员属性属于类的一部分（或 者说是对象的一部分）； 生存时间非静态全局变量加载在堆内存中，随着声明初始化而创建，随着对象消亡而消亡； 是否需要初始化全局变量都是不需要被强制初始化的，系统都会默认根据其数据类型进行默认赋值；但是建议在声明时都进行初始化操作； 创建位置创建在堆内存中，因为非静态的全局变量数对象的成员变量是对象的一部分； 变量属于类的实例对象 随着类的实例被创建而分配内存空间。局部变量形参、方法内定义的变量、代码块中定义的变量。生存时间局部变量的生存时间和方法的生存时间一致，调用该方法声明该局部变量并初始化的时，该局部变量被创建并分配内存空间；直到该方法调用结束局部变量也就结束了；是否需要初始化局部变量在使用前必须进行初始化，系统默认不会对局部变量进行初始化数据操作，如果局部 变量在使用前没有进行初始化则会在编译器报错；如果局部变量进行了声明没有进行初始化， 但是也一直没有被使用的话编译也是不会报错的；（局部变量使用前必须初始化话）创建位置局部变量是创建在栈内存中的在使用变量时需要遵循的原则就近原则代码测试]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[extends]]></title>
      <url>%2F2017%2F02%2F19%2Fextends%2F</url>
      <content type="text"><![CDATA[这次主要分析一下类的关键字 extendsextends表示的是继承，孩子类继承父类，子类继承超类，继承是一种is-a的关系。 示例public class Manager extends Employee() { } 子类可以重写父类的方法（覆盖）这里需要注意，如果子类中重写的这个方法也要用到父类中同名的方法，可以用到super.getSalary() 多态一个对象变量可以指示多种实际类型的现象为多态。 final不允许扩展的类称为final类，即final类不能定义子类。同样子类不能覆盖的方法叫做final方法 final类示例public final class Manager extends Employee() { } final方法示例public class test { public final String getName() { } } final变量（实例变量，静态变量，常量）示例public class finalTest { private final String S = &quot;final实例变量S&quot;; private final int A = 100; public final int B = 90; public static final int C = 80; //同static一起定义常量 private static final int D = 70; public final int E; //final空白,必须在初始化对象的时候赋初值 public finalTest(int x) { E = x; } /** * @param args */ public static void main(String[] args) { finalTest t = new finalTest(2); //t.A=101; //出错,final变量的值一旦给定就无法改变 //t.B=91; //出错,final变量的值一旦给定就无法改变 //t.C=81; //出错,final变量的值一旦给定就无法改变 //t.D=71; //出错,final变量的值一旦给定就无法改变 System.out.println(t.A); System.out.println(t.B); System.out.println(t.C); //不推荐用对象方式访问静态字段 System.out.println(t.D); //不推荐用对象方式访问静态字段 System.out.println(finalTest.C); System.out.println(finalTest.D); //System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. System.out.println(t.E); finalTest t1 = new finalTest(3); System.out.println(t1.E); //final空白变量E依据对象的不同而不同 } } abstract抽象类包含一个或多个抽象方法的类必须被声明为抽象的。在子类中都有必要的操作要进行，但是在超类中却没有什么相关操作需要进行的方法为抽象方法,具体的实现在子类。 示例public abstract class Person { private String name; public Person(String name) { this.name=name; } public abstract String getDescription(); } 一些注意的地方 abstract不能被实例化，即不能创建这个类的对象，但是可以创建一个具体子类的对象。只能引用非抽象子类的对象。 扩展抽象类有两种方法：抽象类中定义部分或者不定义抽象类方法，子类也为abstract类。 抽象类中定义全部抽象方法，子类不是abstract类。 abstract 关键字不能应用于 static、private 或 final 方法，因为这些方法不能被重写，因此，不能在子类中实现。 final 类的方法都不能是 abstract，因为 final 类不能有子类。java中的访问权限 private只有本类可见 Protected本包与所有子类可见 public所有类都可以看到 没有修饰符，只对本包可见。default,不能声明变量。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java集合]]></title>
      <url>%2F2017%2F02%2F18%2FCollection%2F</url>
      <content type="text"><![CDATA[Java集合框架为不同类型的集合定义了大量的接口，这里主要讲解Collection接口，Map接口，Iterator接口。 Collection接口Collection集合体系继承树 Collection接口定义的常用方法 Set中的数据对象没有顺序且不可以重复。 List中的数据对象有顺序且可以重复。 public class CollectioDemo { public static void main(String[] args) { Collection li=new ArrayList(); System.out.println(li);//tostring()方法 li.add(&quot;fanlili&quot;); li.add(&quot;徐ss&quot;); System.out.println(li); Collection li2=new ArrayList();//将一个集合加入到另一个集合中 li2.add(&quot;kek&quot;); li2.add(&quot;mm&quot;); li2.addAll(li); System.out.println(li2); Collection li3=new ArrayList();//对数字的添加直接做了装箱，其实就是Integer li3.add(1); li3.add(3); li3.add(&quot;既有数值又有字符串&quot;);//一般存储同一类型的数据 System.out.println(li3); System.out.println(&quot;-----------------------删除&quot;); /*li2.clear(); System.out.println(li2);*/ /*li3.remove(1); System.out.println(li3);/*?????li2为什么结果不同？？？*/ /*li2.removeAll(li); System.out.println(li2);*/ System.out.println(&quot;-----------------------是否包含&quot;); boolean isexist=li.contains(&quot;fanlili&quot;); System.out.println(isexist); boolean isexist2=li2.containsAll(li); System.out.println(isexist2); boolean isempty=li2.isEmpty(); System.out.println(isempty); Object[] obarray=li2.toArray();//较为重要的将集合转换为数组 for(int i=0;i&lt;obarray.length;i++) { System.out.println(obarray[i]); } } } 运行结果： [] [fanlili, 徐ss] [kek, mm, fanlili, 徐ss] [1, 3, 既有数值又有字符串] -----------------------删除 -----------------------是否包含 true true false kek mm fanlili 徐ss ListArrrayList常用方法（也有collection的那些方法）public class ListDemo { public static void main(String[] args) { List list=new ArrayList(); list.add(&quot;fanlili&quot;); list.add(&quot;ggg&quot;); list.add(1, &quot;xumeng&quot;);//在哪个后面插 list.add(&quot;fanliliwww&quot;); System.out.println(list); Object ob=list.get(2);//根据索引获取元素 System.out.println(ob); int num=list.size(); //获取list的元素个数 System.out.println(num); ListIterator iter=list.listIterator();//ListIterator功能更加强大 while(iter.hasNext()) { Object obj=iter.next(); System.out.println(obj); } System.out.println(&quot;----------------------------------------&quot;); String str= (String)iter.previous();//实现从后向前遍历 System.out.println(str); int pindex=iter.previousIndex();//previousIndex来指示下一个previous()要读取的元素位置 System.out.println(pindex); } } 运行结果如下： [fanlili, xumeng, ggg, fanliliwww] ggg 4 fanlili xumeng ggg fanliliwww ---------------------------------------- fanliliwww 2 vector常用方法（也有collection的那些方法）public class VectorDemo { public static void main(String[] args) { Vector al=new Vector();//构造一个空向量 al.addElement(1); System.out.println(al); al.addElement(new student(&quot;徐ww&quot;,30)); al.addElement(new student(&quot;樊dd&quot;,88)); al.addElement(new student(&quot;文ww&quot;,30)); System.out.println(al); student stu=(student) al.elementAt(1); System.out.println(stu); } } 运行结果： [1] [1, student [name=徐ww, age=30], student [name=樊dd, age=88], student [name=文dd, age=30]] student [name=徐ww, age=30] LinkedList常用方法 boolean add(E e) 将指定元素添加到此列表的结尾。 void add(int index, E element) 在此列表中指定的位置插入指定的元素。 boolean addAll(Collection&lt;? extends E&gt; c) 添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。 boolean addAll(int index, Collection&lt;? extends E&gt; c) 将指定 collection 中的所有元素从指定位置开始插入此列表。 void addFirst(E e) 将指定元素插入此列表的开头。 void addLast(E e) 将指定元素添加到此列表的结尾。 void clear() 从此列表中移除所有元素。 Object clone() 返回此 LinkedList 的浅表副本。 boolean contains(Object o) 如果此列表包含指定元素，则返回 true。 Iterator&lt;E&gt; descendingIterator() 返回以逆向顺序在此双端队列的元素上进行迭代的迭代器。 E element() 获取但不移除此列表的头（第一个元素）。 E get(int index) 返回此列表中指定位置处的元素。 E getFirst() 返回此列表的第一个元素。 E getLast() 返回此列表的最后一个元素。 int indexOf(Object o) 返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。 int lastIndexOf(Object o) 返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。 ListIterator&lt;E&gt; listIterator(int index) 返回此列表中的元素的列表迭代器（按适当顺序），从列表中指定位置开始。 boolean offer(E e) 将指定元素添加到此列表的末尾（最后一个元素）。 boolean offerFirst(E e) 在此列表的开头插入指定的元素。 boolean offerLast(E e) 在此列表末尾插入指定的元素。 E peek() 获取但不移除此列表的头（第一个元素）。 E peekFirst() 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。 E peekLast() 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。 E poll() 获取并移除此列表的头（第一个元素） E pollFirst() 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。 E pollLast() 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。 E pop() 从此列表所表示的堆栈处弹出一个元素。 void push(E e) 将元素推入此列表所表示的堆栈。 E remove() 获取并移除此列表的头（第一个元素）。 E remove(int index) 移除此列表中指定位置处的元素。 boolean remove(Object o) 从此列表中移除首次出现的指定元素（如果存在）。 E removeFirst() 移除并返回此列表的第一个元素。 boolean removeFirstOccurrence(Object o) 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。 E removeLast() 移除并返回此列表的最后一个元素。 boolean removeLastOccurrence(Object o) 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。 E set(int index, E element) 将此列表中指定位置的元素替换为指定的元素。 int size() 返回此列表的元素数。 Object[] toArray() 返回以适当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组。 &lt;T&gt; T[] toArray(T[] a) 返回以适当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组；返回数组的运行时类型为指定数组的类型。 public class LinkedListDemo { public static void main(String[] args) { stack(); } public static void stack() { LinkedList al=new LinkedList(); al.push(new student(&quot;徐ww&quot;,30)); al.push(new student(&quot;樊dd&quot;,88)); al.push(new student(&quot;文dd&quot;,30)); student stu=(student) al.pop(); System.out.println(&quot;------------------------&quot;); Iterator iter=al.iterator(); while(iter.hasNext()) { //获得集合中的一个元素 Object obj=iter.next(); System.out.println(obj); } } } 运行结果： ------------------------ student [name=樊dd, age=88] student [name=徐ww, age=30] *push元素推入此列表所表示的堆栈，add是将指定元素添加到此列表的结尾。 三者的区别： ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。 LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 插入一个泛型示例*为了创建容器类，有了泛型，用&lt;&gt;括起来，在编译期，是无法知道K和V具体是什么类型，只有在运行时才会真正根据类型来构造和分配内存。 泛型接口 public interface Generator&lt;T&gt; public class FruitGenerator implements Generator&lt;String&gt; FruitGenerator generator = new FruitGenerator(); 泛型类 public class Test&lt;T&gt;{} Test&lt;Object&gt; t = new Test&lt;Object&gt;(); 泛型方法 public static &lt;T&gt; void out(T t) { System.out.println(t); } 结合集合的示例 public interface BaseDao&lt;T&gt; { public void save(T t); public T getT(Integer i); public List&lt;T&gt; listT(); } public class StudentImplDemo implements BaseDao&lt;student&gt; { List&lt;student&gt; sList=new ArrayList&lt;student&gt;(); @Override public void save(student t) { sList.add(t); } @Override public student getT(Integer i) { sList.get(i); return null; } @Override public List&lt;student&gt; listT() { return sList; } } public class studentTest { private static BaseDao&lt;student&gt; basedao=new StudentImplDemo(); public static void main(String[] args) { student s=new student(&quot;xumeng&quot; ,88); student s1=new student(&quot;xumengf&quot; ,80); basedao.save(s); basedao.save(s1); List&lt;student&gt; slist=basedao.listT(); System.out.println(slist); } } Set未完待续]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MavenStudy]]></title>
      <url>%2F2017%2F01%2F30%2FMavenStudy%2F</url>
      <content type="text"><![CDATA[Maven是用来干什么的管理项目的工具下载我的jdk是1.8下载版本为3.3.9配置环境变量配置 maven 环境变量(系统变量)：MAVEN_HOME F:\maven\apache-maven-3.3.9在path中添加：;%MAVEN_HOME%\binmaven 版的helloworldmaven 要用到本地仓库，没有会去联网下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[你好]]></title>
      <url>%2F2017%2F01%2F29%2Ftet%2F</url>
      <content type="text"><![CDATA[首先需要明白在这里怎么发表博客怎么来玩我觉得我们都要这样爱初二呼和扩说扩军多活菌多菌或扩多索扩所扩军多敷或多敷或获付俊福军副扩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test]]></title>
      <url>%2F2017%2F01%2F29%2Ftest%2F</url>
      <content type="text"><![CDATA[hwhwhwhwhwhwhwhwwhwhhwhwhwhwhwwwwwwwww是护手霜上海市jdjdjdjdj是护手霜上海市shh MyButton]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F01%2F25%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Quick Start]]></content>
    </entry>

    
  
  
</search>
